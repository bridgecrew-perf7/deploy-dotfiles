= deploy-dotfiles.sh
:toc:       left
:toclevels: 3

Simplified multi-platform dotfile management.

(WORK IN PROGRESS--very much a rough draft)

== What it do
I have oft found myself needing to maintain 3-4 versions of my dotfiles.
A _.bashrc_ for macOS, my work machine, personal linux box, etc.
All of which have subtle differences in the prompts, aliases, or defaults.

This projects allows for a single file with variables (denoted as `{{...}}`) to be used.
Key:value pairs are defined in a second file.
If a matching value is found, it is substituted into the text.
After parsing it's linked to the destination.


== Installation
.External dependencies
. `bash >=4.2`
. `gawk`
. `sed`

.Other dependencies
. `@hre-utils/mk-conf.sh`

.Install
[source,bash]
----
# Assuming an ubuntu system...

#  1. Install general deps:
sudo apt-get update -y
sudo apt-get upgrade -y
sudo apt-get install gawk sed

#  2. Install script deps:
git clone https://github.com/hre-utils/mk-conf
chmod +x ./mk-conf/mk-conf.sh
mv ./mk-conf/mk-conf.sh /usr/local/bin

#  3. Install this script:
git clone https://github.com/hre-utils/deploy-dotfiles
chmod +x ./deploy-dotfiles/deploy-dotfiles.sh
mv ./deploy-dotfiles/deploy-dotfiles.sh /usr/local/bin
----


== How it do
=== Usage & Definitions
[source]
----
USAGE: ./deploy-dotfiles.sh [OPTION] [COMMAND]

Options:
   -h | --help              show this message and exit
   -b | --build-only        compile output to 'dist/', do not deploy to
   -d | --debug LOW[,HIGH]  set debug level range

Commands:
   -c | --clean NUMBER      purges ./dist, maintaining NUMBER entries
   -n | --new PATH          inits new base directory, copying PATH if exists
----

.Terms
base (file)::
   The contents of a configuration file, containing regular text, and key:value pairs substituted during compilation.
   Located at `files/$NAME/base`.

base (section)::
   The leading section of a local configuration file, specifying per-directory options.

global config::
   Configuration settings set for compilation & deployment.
   It is  loaded prior to per-directory local options.
   Located at `config.cfg`

local config::
   Per-directory configuration file.
   It is loaded after global options, thus you may override a global default for a single file.
   Located at `files/$NAME/config.cfg`. 

.cfg (format)::
   A file format commonly used for config files.
   Characterized by bracket enclosed headings, and use of multiple brackets to denote sub-heading levels.
   Mine may be parsed non-traditionally, see https://github.com/hre-utils/mk-conf[@hre-utils/mk-conf] for more info.


=== Directory Structure
The requisite directory structure is created at either:

. `$XDG_DATA_HOME/hre-utils/deploy-dotfiles/`, or
. `~/.local/share/hre_utils/deploy-dotfiles/`

[source]
----
deploy-dotfiles/
 ├── backup/                     # <- prevent over-writing, files dropped here
 ├── dist/                       # <- compiled output
 ├── files/
 │    ├── vimrc/
 │    │     ├── base             # <- base dotfile (contains variables)
 │    │     └── options.cfg      # <- local config
 │    └── bashrc/
 │         ├── base
 │         └── options.cfg
 └── options.cfg                 # <- global config
----

=== Example(s)
==== Adding a new file
[source]
----
./deploy-dotfiles.sh --new ~/.vimrc
----

.Does
. Creates new directory under _files/_.
. Default local _options.cfg_ is written.
. Either copies file from `$PATH` to '`base`', or creates empty file

==== Building only
[source]
----
./deploy-dotfiles.sh --build-only
----

.Does
. Compiles all '`base`' files
. Moves into _dist/_, named after seconds since epoch

.Does not
. Deploy to final destination

==== Pruning dist/
[source]
----
./deploy-dotfiles.sh --clean [NUM]
----

.Does
. Deletes all files from _dist/_, save for the most recent `$NUM` (default 3)

== What else
=== Safety
Decent error checking.

Sane defaults.

It should be difficult for one to accidentally nuke a config file.
If an existing dotfile is found at the deployment location, it is backed up via one of several methods:

. Moved _(default)_: re-located to the `backup` directory, renamed to last modification time
. In-place: given `.bak` suffix
. Removed: `rm -i` to provide confirmation & interactively remove

Should the user choose to not back up a potentially overwritten file, the default copy command is `cp -i`.
There's plenty opportunity to prevent data loss, unless specifically chosen not to.


=== Portability
Very few dependencies.

Aside from a couple bash scripts you can easily clone, you'll probably have everything installed already.
Anyone with bash >=4.2 and gawk/sed should be set.
You don't have to download the entirety of Python3, or nonsense ruby gems.

You're welcome.


=== Logging & Troubleshooting
Fairly comprehensive log output.

Turn on log levels by passing `--debug LOW[,HIGH]`.
Levels go from -1 (for absolute noise), to 3 (critical errors).

Each run initially generates a '`RUN_ID`' (seconds since the epoch).
The compiled files in _dist/_ are each named after the RUN_ID, to match against specific logfile output.
Allows for easier troubleshooting.


== Why it do
Bash == best.

Using the language for things it was unequivocally not intended is a wonderful way to gain a deeper understanding of it.
No one in their right mind would make a lexer in bash... so I had to.

It also keeps the footprint & dependencies small, which make it portable.


== To do
.Refactor & Bugfixes
* [ ] '`Library`' files contain too many conflicting global variables when sourcing.
      `PROGDIR` ends up being set to the path of the last-sourced file.
      Several proposed solutions noted in the comments.

.Features
* [ ] CLI options:
    ** [x] `--new` Automatically create the requisite directory structure
    ** [x] `--clean` Remove >3 files from each dir in ./dist.
    ** [ ] `--find` Echo path to the '`base`' of a specified search term

* [ ] Re-work type :multiline and :text in `mk-conf.sh`, such that we can specify longer sections of text to drop in.
      While specifying files in `./files/$NAME/additions/` may be a more elegant solution for long additions, 4-5 line chunks seem best via a :multiline entry.

* [ ] Reporting.
      Compile information during the run into a final report.
      Use a trap to ensure the report is actually written on exits or failure.
      Report should contain: 1) exit status, 2) run summary, 3) operations performed, 4) errors encountered.
      Use `less -r` to show with color escapes enabled.

* [ ] Easier option for files that don't have any processing required.
      If it it something that's as simple as a 'cp' with no variables.

* [ ] Create deployment script, move data to XDG_DATA_HOME or .local/share

* [ ] Add `write` function. Similar to `debug`.
      For writing necessary output to the terminal.
      Will need to be quieted by `-q|--quiet`.

* [ ] When stripping newlines, also consider situations of `$'\n'`, `$' '`, `$'\n'`.
      Need a lookahead +2, or a lookbehind.

* [ ] Maybe set up `fswatch` for auto-compiling files from base?


.Done
* [x] Tokenize new text that's entered from the config.cfg file, such that we can properly strip newlines.

* [x] Diff previously generated files.
      If there's no differences, no need to compile them again.
      Best way to do this might be a dotfile within each `./dist/$NAME` with a md5sum of the base file, and the filename it's created.
      Before running, we md5sum the '`base`' file, grep the list to see if there's an existing entry.

* [x] Make consistent global variables for common paths.
      The names should be straightforward, memorable, and obviously distinct to which directory they refer.

* [x] Clean up terminology.
      We're referring to '`base`' in like 3 different ways.
      As with variables, things should have one (and only one) clear name.
